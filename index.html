<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">

<!-- No cache for GitHub Pages testing -->
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">

<title>Asteroids – Final</title>

<style>
  body {
    margin: 0;
    background: black;
    color: white;
    font-family: monospace;
    text-align: center;
  }
  canvas {
    display: block;
    margin: 20px auto;
    border: 4px solid white;
    background: black;
  }
</style>
</head>

<body>
<h1>Asteroids</h1>
<p>↑ thrust · ← → rotate · Space fire</p>

<canvas id="game" width="512" height="512"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

/* INPUT */
const keys = {};
addEventListener("keydown", e => keys[e.key] = true);
addEventListener("keyup", e => keys[e.key] = false);

/* CONSTANTS */
const W = 512, H = 512;
const GRAVITY = 0.02;
const DAMPING = 0.995;

/* GAME STATE */
let ship, bullets, asteroids, particles, stars;
let dead = false;
let resetTimer = 0;
let score = 0;

/* AUDIO */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function beep(freq, time) {
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.frequency.value = freq;
  o.connect(g);
  g.connect(audioCtx.destination);
  o.start();
  g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + time);
  o.stop(audioCtx.currentTime + time);
}

/* WRAP */
function wrap(o, r = 0) {
  if (o.x < -r) o.x = W + r;
  if (o.x > W + r) o.x = -r;
  if (o.y < -r) o.y = H + r;
  if (o.y > H + r) o.y = -r;
}

/* ASTEROID SHAPE */
function generateAsteroidShape(size) {
  const points = [];
  const verts = Math.floor(Math.random() * 5) + 7;
  for (let i = 0; i < verts; i++) {
    const angle = (Math.PI * 2 / verts) * i;
    const radius = size * (0.6 + Math.random() * 0.5);
    points.push({ angle, radius });
  }
  return points;
}

/* RESET */
function resetGame() {
  ship = {
    x: W / 2, y: H / 2,
    vx: 0, vy: 0,
    angle: -Math.PI / 2,
    radius: 12,
    thrust: 0.15,
    rotationSpeed: 0.05,
    cooldown: 0
  };

  bullets = [];
  asteroids = [];
  particles = [];
  stars = [];

  for (let i = 0; i < 5; i++) spawnAsteroid(40);
  for (let i = 0; i < 80; i++) {
    stars.push({
      x: Math.random() * W,
      y: Math.random() * H,
      speed: Math.random() * 0.3 + 0.1
    });
  }

  score = 0;
  dead = false;
}

/* ASTEROIDS */
function spawnAsteroid(size, x, y) {
  if (x === undefined) {
    const edge = Math.floor(Math.random() * 4);
    if (edge === 0) { x = 0; y = Math.random() * H; }
    if (edge === 1) { x = W; y = Math.random() * H; }
    if (edge === 2) { x = Math.random() * W; y = 0; }
    if (edge === 3) { x = Math.random() * W; y = H; }
  }

  asteroids.push({
    x, y,
    size,
    vx: (Math.random() - 0.5) * (60 / size),
    vy: (Math.random() - 0.5) * (60 / size),
    angle: Math.random() * Math.PI * 2,
    spin: (Math.random() - 0.5) * 0.01,
    shape: generateAsteroidShape(size)
  });
}

/* EXPLOSIONS */
function explode(x, y, count) {
  for (let i = 0; i < count; i++) {
    particles.push({
      x, y,
      vx: (Math.random() - 0.5) * 4,
      vy: (Math.random() - 0.5) * 4,
      life: Math.random() * 40 + 20
    });
  }
}

resetGame();

/* LOOP */
function loop() {

  ctx.fillStyle = "black";
  ctx.fillRect(0, 0, W, H);

  /* STARFIELD */
  ctx.fillStyle = "white";
  for (let s of stars) {
    s.y += s.speed;
    if (s.y > H) s.y = 0;
    ctx.fillRect(s.x, s.y, 1, 1);
  }

  /* DEBUG */
  ctx.fillStyle = "magenta";
  ctx.fillRect(4, 4, 8, 8);

  /* SHIP UPDATE */
  if (!dead) {
    if (keys["ArrowLeft"]) ship.angle -= ship.rotationSpeed;
    if (keys["ArrowRight"]) ship.angle += ship.rotationSpeed;
    if (keys["ArrowUp"]) {
      ship.vx += Math.cos(ship.angle) * ship.thrust;
      ship.vy += Math.sin(ship.angle) * ship.thrust;
    }

    ship.vy += GRAVITY;
    ship.vx *= DAMPING;
    ship.vy *= DAMPING;

    ship.x += ship.vx;
    ship.y += ship.vy;
    wrap(ship, ship.radius);

    if (keys[" "] && ship.cooldown <= 0) {
      bullets.push({
        x: ship.x, y: ship.y,
        vx: Math.cos(ship.angle) * 6,
        vy: Math.sin(ship.angle) * 6,
        life: 90
      });
      beep(600, 0.05);
      ship.cooldown = 10;
    }
    ship.cooldown--;
  }

  /* BULLETS */
  for (let b of bullets) {
    b.x += b.vx;
    b.y += b.vy;
    b.life--;
    wrap(b, 2);
  }
  bullets = bullets.filter(b => b.life > 0);

  /* ASTEROIDS */
  for (let a of asteroids) {
    a.x += a.vx;
    a.y += a.vy;
    a.angle += a.spin;
    wrap(a, a.size);
  }

  /* BULLET ↔ ASTEROID */
  for (let i = bullets.length - 1; i >= 0; i--) {
    for (let j = asteroids.length - 1; j >= 0; j--) {
      const b = bullets[i];
      const a = asteroids[j];
      if (Math.hypot(b.x - a.x, b.y - a.y) < a.size) {
        bullets.splice(i, 1);
        asteroids.splice(j, 1);
        explode(a.x, a.y, 20);
        beep(200, 0.1);
        score += 100;

        if (a.size > 30) {
          spawnAsteroid(a.size / 2, a.x, a.y);
          spawnAsteroid(a.size / 2, a.x, a.y);
        }
        break;
      }
    }
  }

  /* SHIP ↔ ASTEROID */
  if (!dead) {
    for (let a of asteroids) {
      if (Math.hypot(ship.x - a.x, ship.y - a.y) < ship.radius + a.size) {
        dead = true;
        resetTimer = 60;
        explode(ship.x, ship.y, 40);
        beep(80, 0.3);
        break;
      }
    }
  } else {
    resetTimer--;
    if (resetTimer <= 0) resetGame();
  }

  /* PARTICLES */
  ctx.fillStyle = "orange";
  for (let p of particles) {
    p.x += p.vx;
    p.y += p.vy;
    p.life--;
    ctx.fillRect(p.x, p.y, 2, 2);
  }
  particles = particles.filter(p => p.life > 0);

  /* DRAW SHIP */
  if (!dead) {
    ctx.save();
    ctx.translate(ship.x, ship.y);
    ctx.rotate(ship.angle);
    ctx.strokeStyle = "cyan";
    ctx.beginPath();
    ctx.moveTo(12, 0);
    ctx.lineTo(-10, -8);
    ctx.lineTo(-6, 0);
    ctx.lineTo(-10, 8);
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
  }

  /* DRAW BULLETS */
  ctx.fillStyle = "white";
  for (let b of bullets) {
    ctx.fillRect(b.x - 2, b.y - 2, 4, 4);
  }

  /* DRAW ASTEROIDS (SOLID) */
  for (let a of asteroids) {
    ctx.save();
    ctx.translate(a.x, a.y);
    ctx.rotate(a.angle);

    ctx.beginPath();
    a.shape.forEach((p, i) => {
      const x = Math.cos(p.angle) * p.radius;
      const y = Math.sin(p.angle) * p.radius;
      i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    });
    ctx.closePath();

    ctx.fillStyle = "#777";
    ctx.strokeStyle = "#aaa";
    ctx.fill();
    ctx.stroke();

    ctx.restore();
  }

  /* SCORE */
  ctx.fillStyle = "white";
  ctx.fillText("SCORE: " + score, 20, 20);

  requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
